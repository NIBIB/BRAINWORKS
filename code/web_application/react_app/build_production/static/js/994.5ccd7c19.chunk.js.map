{"version":3,"file":"static/js/994.5ccd7c19.chunk.js","mappings":"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","sources":["common/components/Card/index.tsx","common/components/FlaskField/blocks/FormikValidationWrapper/index.tsx","common/components/FlaskField/blocks/FormikImageCaptcha/index.tsx","common/components/FlaskField/blocks/FormikNumberInput/index.tsx","common/components/FlaskField/blocks/FormikStringArray/TagArray.tsx","common/components/FlaskField/blocks/FormikStringArray/FormikAutoComplete.tsx","common/components/FlaskField/blocks/FormikStringArray/index.tsx","common/components/FlaskField/blocks/FormikTextField/index.tsx","common/components/FlaskField/index.tsx","common/components/FlaskForm/GeneratedForm.tsx","common/components/FlaskForm/InvalidToken.tsx","common/components/FlaskForm/FormikWrapper.tsx","common/components/FlaskForm/index.tsx","common/hooks/useAPIDataAlert.tsx","common/hooks/useGlobalAlert.tsx","common/hooks/useGlobalFormik.tsx","common/utils.ts"],"sourcesContent":["import { Box } from \"@chakra-ui/react\";\nimport React, { forwardRef } from \"react\";\nimport type { BoxProps } from \"@chakra-ui/react\";\n\ninterface AppProps {\n  children: React.ReactNode;\n  /**\n   * `props` - ChakraUI's box properties\n   */\n  boxProps?: BoxProps;\n}\n\n/**\n * Card\n *\n * React component that renders a reusable card component wrapper\n */\nconst Card = forwardRef<HTMLDivElement, AppProps>(\n  ({ children, boxProps }, ref) => {\n    return (\n      <Box\n        border={\"1px\"}\n        borderColor={\"gray.200\"}\n        overflow={\"hidden\"}\n        opacity={\"100%\"}\n        bg={\"white\"}\n        h={\"100%\"}\n        w={\"100%\"}\n        {...boxProps}\n        ref={ref}\n      >\n        {children}\n      </Box>\n    );\n  }\n);\n\nexport default Card;\n","import { FormControl, FormErrorMessage, FormLabel } from \"@chakra-ui/react\";\nimport useGlobalFormik from \"common/hooks/useGlobalFormik\";\nimport { useFormikContext } from \"formik\";\nimport { ReactNode } from \"react\";\n\ninterface AppProps {\n  property: string;\n  children: ReactNode;\n  hideInvalidMsg?: boolean;\n}\n\n/**\n * FormikValidationWrapper\n *\n * React component that wraps FlaskField components with a label and error message\n */\nconst FormikValidationWrapper = ({\n  hideInvalidMsg,\n  children,\n  property,\n}: AppProps) => {\n  const formik = useFormikContext<any>();\n  const { errors } = formik;\n  const { formikSlice } = useGlobalFormik();\n  const field = formikSlice.fieldsInfo.filter(\n    (item: any) => item.property === property\n  )[0];\n  return (\n    <>\n      <FormControl\n        isRequired={field?.required ? field.required : false}\n        isInvalid={!!formik.errors[property] && !!formik.touched[property]}\n      >\n        <FormLabel htmlFor={property}>{field?.title}</FormLabel>\n        {children}\n        {!hideInvalidMsg && (\n          <FormErrorMessage>{errors[property]?.toString()}</FormErrorMessage>\n        )}\n      </FormControl>\n    </>\n  );\n};\n\nexport default FormikValidationWrapper;\n","import DOMPurify from \"dompurify\";\nimport {\n  Box,\n  Divider,\n  FormControl,\n  Heading,\n  HStack,\n  IconButton,\n  Image,\n  Input,\n  Skeleton,\n  VStack,\n} from \"@chakra-ui/react\";\nimport useGlobalFormik from \"../../../../hooks/useGlobalFormik\";\nimport Card from \"../../../Card\";\nimport { brandColorScheme } from \"../../../../../setup/theme/colors\";\nimport { FiRepeat } from \"react-icons/fi\";\nimport { Field, useFormikContext } from \"formik\";\nimport FormikValidationWrapper from \"../FormikValidationWrapper\";\n\n/**\n * ImageCAPTCHA\n *\n * React component that renders an ImageCAPTCHA component that takes the `math` property\n */\nconst ImageCAPTCHA = () => {\n  const { formikSlice, newCaptcha } = useGlobalFormik();\n  const { captcha } = formikSlice;\n  const formik = useFormikContext<any>();\n\n  const field = formikSlice.fieldsInfo.filter(\n    (item: any) => item.property === \"math\"\n  )[0];\n\n  return (\n    <>\n      <Card\n        boxProps={{\n          w: \"auto\",\n          h: \"auto\",\n          bg: \"gray.50\",\n          p: 3,\n        }}\n      >\n        <VStack spacing={2}>\n          <Box w=\"100%\">\n            <Heading\n              textAlign=\"left\"\n              fontSize=\"xs\"\n              color=\"gray.500\"\n              fontWeight={500}\n              mb={2}\n            >\n              CAPTCHA\n            </Heading>\n            <Divider />\n          </Box>\n          <Skeleton\n            startColor=\"white\"\n            endColor=\"white\"\n            isLoaded={captcha.img.length > 0}\n            w=\"100%\"\n          >\n            <Image\n              border=\"1px\"\n              borderColor=\"gray.300\"\n              p={2}\n              h={10}\n              bg=\"white\"\n              w={\"100%\"}\n              src={DOMPurify.sanitize(captcha.img)}\n            />\n          </Skeleton>\n          <HStack align=\"flex-end\" w=\"100%\">\n            <Box w=\"100%\">\n              <FormikValidationWrapper property=\"math\">\n                <Field\n                  as={Input}\n                  id=\"math\"\n                  autoComplete=\"off\"\n                  name=\"math\"\n                  noValidate={false}\n                ></Field>\n              </FormikValidationWrapper>\n            </Box>\n            {/* <IconButton\n              colorScheme={brandColorScheme}\n              aria-label=\"Volume\"\n              size=\"md\"\n              icon={<VolumeUp />}\n              onClick={() => {\n                const audio = new Audio(URL + captcha.audio);\n                audio?.play();\n              }}\n            /> */}\n            <IconButton\n              colorScheme={brandColorScheme}\n              aria-label=\"Refresh\"\n              size=\"md\"\n              icon={<FiRepeat />}\n              onClick={newCaptcha}\n            />\n          </HStack>\n        </VStack>\n      </Card>\n    </>\n  );\n};\n\nexport default ImageCAPTCHA;\n","import {\n  NumberInput,\n  NumberInputField,\n  NumberInputStepper,\n  NumberIncrementStepper,\n  NumberDecrementStepper,\n} from \"@chakra-ui/react\";\nimport { useFormikContext } from \"formik\";\n\ninterface AppProps {\n  /**\n   * `string` is the name of the property\n   */\n  property: string;\n}\n\nconst FormikNumberInput = ({ property }: AppProps) => {\n  const { values, setFieldValue } = useFormikContext<any>();\n\n  // * Returns all field info, give property\n\n  const handleNumberInputChange = (value: string) => {\n    setFieldValue(property, value);\n  };\n\n  return (\n    <NumberInput\n      onChange={handleNumberInputChange}\n      w=\"100%\"\n      value={values[property]}\n      min={1}\n      bg=\"white\"\n      max={999}\n    >\n      <NumberInputField />\n      <NumberInputStepper>\n        <NumberIncrementStepper />\n        <NumberDecrementStepper />\n      </NumberInputStepper>\n    </NumberInput>\n  );\n};\n\nexport default FormikNumberInput;\n","import { Tag, TagCloseButton, TagLabel, Wrap } from \"@chakra-ui/react\";\nimport { brandColorScheme } from \"../../../../../setup/theme/colors\";\n\ninterface AppProps {\n  /**\n   * array - `string array` String array holding all tag labels\n   */\n  array: string[];\n  /**\n   * property - `string` Property key of value object\n   */\n  property: string;\n  /**\n   * On close - `function` Function that runs when tag close is clicked, removes tag from list\n   */\n  onClose: any;\n}\n\n/**\n * TagArray\n *\n * React component that maps array of strings to Chakra UI tags with the ability to remove the tags\n */\nconst TagArray = ({ array, onClose, property }: AppProps) => {\n  return (\n    <Wrap>\n      {array?.map((value: string, index: number) => (\n        <Tag\n          size={\"sm\"}\n          key={index}\n          variant=\"subtle\"\n          colorScheme={brandColorScheme}\n        >\n          <TagLabel>{value}</TagLabel>\n          <TagCloseButton\n            onClick={() => {\n              const filtered = array.filter((item: string) => item !== value);\n              onClose(property, filtered);\n            }}\n          />\n        </Tag>\n      ))}\n    </Wrap>\n  );\n};\n\nexport default TagArray;\n","import { Box } from \"@chakra-ui/react\";\n\ninterface AppProps {\n  /**\n   * `string[]` -\n   */\n  searchQuery: string[];\n  curSelected: number;\n  setCurSelected: (val: number) => void;\n  show: boolean;\n  addFormValue: (value: string) => void;\n}\n\n/**\n * FormikAutoComplete\n *\n * If a valid autocomplete file string is given, pulls that autocomplete file and allows user to select from list\n */\nconst FormikAutoComplete = ({\n  searchQuery,\n  curSelected,\n  show,\n  setCurSelected,\n  addFormValue,\n}: AppProps) => {\n  return (\n    <>\n      {show && (\n        <Box\n          id=\"tries\"\n          border=\"1px\"\n          borderRadius=\"sm\"\n          borderColor=\"gray.300\"\n          w=\"100%\"\n          pos=\"absolute\"\n          top=\"105%\"\n          bg=\"white\"\n          zIndex={1000}\n          tabIndex={0}\n          boxShadow=\"md\"\n        >\n          {/* Autocomplete list items */}\n          {searchQuery?.length > 0 ? (\n            searchQuery.map((result, index) => {\n              return (\n                <Box\n                  w=\"100%\"\n                  textAlign={\"left\"}\n                  p=\"10px\"\n                  bg={curSelected === index ? \"gray.100\" : \"white\"}\n                  key={result[0]}\n                  onMouseOver={() => {\n                    setCurSelected(index);\n                  }}\n                  onClick={() => {\n                    addFormValue(searchQuery[curSelected][0]);\n                  }}\n                >\n                  {result[0]}\n                  <Box as={\"span\"} color={\"gray.600\"} ml={\"3\"}>\n                    {result[1].toLocaleString()} results\n                  </Box>\n                </Box>\n              );\n            })\n          ) : (\n            <Box w=\"100%\" textAlign={\"left\"} p=\"10px\" bg={\"white\"}>\n              <Box as={\"span\"} color={\"gray.600\"} ml={\"3\"}>\n                Your search did not yield any results\n              </Box>\n            </Box>\n          )}\n        </Box>\n      )}\n    </>\n  );\n};\n\nexport default FormikAutoComplete;\n","import {\n  Box,\n  Button,\n  Input,\n  InputGroup,\n  InputRightElement,\n} from \"@chakra-ui/react\";\nimport useAxios from \"axios-hooks\";\nimport { useFormikContext } from \"formik\";\nimport {\n  ChangeEvent,\n  FocusEvent,\n  KeyboardEvent,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport useGlobalFormik from \"../../../../hooks/useGlobalFormik\";\nimport useGlobalAlert from \"../../../../hooks/useGlobalAlert\";\nimport TagArray from \"./TagArray\";\nimport FormikAutoComplete from \"./FormikAutoComplete\";\nimport { API_URL } from \"../../../../templates/api\";\nimport { getFieldInfo, matchItems } from \"../../../../utils\";\nimport { FiPlus } from \"react-icons/fi\";\n\ninterface AppProps {\n  /**\n   * `string` is the name of the property\n   */\n  property: string;\n}\n/**\n *\n * FormikStringArray\n *\n * React component that renders an input field that adds to a string array on submit/return\n */\nconst FormikStringArray = ({ property }: AppProps) => {\n  const { formikSlice } = useGlobalFormik();\n  const { values, setFieldValue } = useFormikContext<any>();\n  const { showGlobalAlert } = useGlobalAlert();\n  const inputRef = useRef<HTMLInputElement | null>(null);\n\n  // * State tracks current input in form field, on `enter` key the field clears and is added to the Formik values\n  const [curInput, setCurInput] = useState(\"\");\n\n  // * Tracks autocomplete full data\n  const [autoArr, setAutoArr] = useState<string[]>([]);\n\n  // * Tracks current selected autocomplete item\n  const [curSelected, setCurSelected] = useState(0);\n\n  // * Enables / disables autocomplete popup based on clicking off the popup/pressing esc\n  const [show, setShow] = useState(false);\n\n  // * Returns all field info, give property\n  const field = getFieldInfo(formikSlice.fieldsInfo, property);\n\n  // * Add input to form value\n  const addFormValue = (value: string) => {\n    // * Don't add empty value\n    if (value.length === 0) {\n      showGlobalAlert(\"Error!\", \"Please write a term to add\", \"error\", 3000);\n      return;\n    }\n    // * Not add duplicate\n    if (values[property]?.includes(value)) {\n      showGlobalAlert(\n        \"Error!\",\n        \"Please do not add duplicate values\",\n        \"error\",\n        3000\n      );\n      return;\n    }\n    const valuesArr = values[property];\n    if (valuesArr) {\n      setFieldValue(property, [...valuesArr, value]);\n    } else {\n      setFieldValue(property, [value]);\n    }\n    // * Set current input to empty string\n    setCurInput(\"\");\n  };\n\n  // * Fetch autocomplete files\n  const [, getAutocomplete] = useAxios<any>(\n    {\n      url: `${API_URL}/autocomplete/${field?.autocomplete}`,\n      withCredentials: true,\n    },\n    { manual: true }\n  );\n\n  // * Fetch autocomplete files if autocomplete file is given\n  useEffect(() => {\n    const loadAutocomplete = async () => {\n      const { data } = await getAutocomplete();\n      setAutoArr(data);\n    };\n    if (field?.autocomplete) {\n      loadAutocomplete();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [field?.autocomplete]);\n\n  // * Rerenders autocomplete query if input\n  const searchQuery = useMemo<string[]>(() => {\n    if (field?.autocomplete && show) {\n      if (curInput.length > 0) {\n        return matchItems(curInput, autoArr);\n      }\n      return matchItems(\"a\", autoArr);\n    }\n  }, [field?.autocomplete, curInput, autoArr, show]);\n\n  return (\n    <Box w=\"100%\">\n      {values[property]?.length > 0 && (\n        <Box mb={3}>\n          <TagArray\n            array={values[property]}\n            property={property}\n            onClose={setFieldValue}\n          />\n        </Box>\n      )}\n      <InputGroup>\n        <Input\n          ref={inputRef}\n          type=\"input\"\n          id={property}\n          value={curInput}\n          autoComplete=\"off\"\n          onChange={(e: ChangeEvent<HTMLInputElement>) => {\n            setCurInput(e.currentTarget.value);\n          }}\n          name={property}\n          onBlur={(_event: FocusEvent<HTMLInputElement>) => {\n            // * When focusing the input initially, setShow to false, hide autocorrect\n            setTimeout(() => {\n              setShow(false);\n            }, 100);\n          }}\n          onFocus={(_event: FocusEvent<HTMLInputElement>) => {\n            // * When focusing the input initially, setShow to true, hide autocorrect\n            setShow(true);\n          }}\n          onKeyDown={(event: KeyboardEvent<HTMLInputElement>) => {\n            const { key } = event;\n            // * Autocomplete field is currently enabled\n            if (show && searchQuery?.length > 0) {\n              const newValue = searchQuery[curSelected][0];\n              if (key === \"ArrowDown\") {\n                // * Move current selected up and down (min 0, max 4)\n                if (curSelected < 4) {\n                  setCurSelected((prevState) => prevState + 1);\n                } else {\n                  setCurSelected(0);\n                }\n              }\n              if (key === \"ArrowUp\") {\n                if (curSelected > 0) {\n                  setCurSelected((prevState) => prevState - 1);\n                } else {\n                  setCurSelected(4);\n                }\n              }\n              // * Submit currently selected search query\n              if (key === \"Enter\" || key === \"Tab\") {\n                addFormValue(newValue);\n              }\n            } else {\n              //* On \"enter key\", add value to string array if it does not exist already\n              if (key === \"Enter\" || key === \"Tab\") {\n                // * Reject if added value is not in search query & autocomplete field is enabled\n                if (field?.autocomplete.length > 0) {\n                  showGlobalAlert(\n                    \"Warning!\",\n                    \"Please submit a value from the autocomplete dropdown\",\n                    \"warning\",\n                    3000\n                  );\n                  return;\n                }\n                addFormValue(curInput);\n              }\n            }\n          }}\n        />\n\n        {/* <InputRightElement width=\"6.5rem\">\n          <Button\n            variant=\"outline\"\n            h=\"1.75rem\"\n            size=\"xs\"\n            leftIcon={<FiPlus />}\n            onClick={() => {\n              if (field?.autocomplete) {\n                // * Autocomplete enabled, make the button show autocomplete on first press\n                if (inputRef) {\n                  console.log(\"focus\");\n                  inputRef.current?.focus();\n                }\n              } else {\n                // * Autocomplete not enable, just add current input\n                addFormValue(curInput);\n              }\n            }}\n          >\n            Add term\n          </Button>\n        </InputRightElement> */}\n      </InputGroup>\n      {/* Autocomplete list if exists */}\n      {field?.autocomplete.length > 0 && (\n        <FormikAutoComplete\n          searchQuery={searchQuery}\n          curSelected={curSelected}\n          setCurSelected={setCurSelected}\n          show={show}\n          addFormValue={addFormValue}\n        />\n      )}\n    </Box>\n  );\n};\nexport default FormikStringArray;\n","import { Input, Select, Textarea } from \"@chakra-ui/react\";\nimport useGlobalFormik from \"common/hooks/useGlobalFormik\";\nimport { Field } from \"formik\";\n\ntype AppProps = {\n  property: string;\n};\n\nconst COMPONENT_TYPE: any = {\n  select: Select,\n  input: Input,\n  textarea: Textarea,\n};\n\n/**\n * FormikField\n *\n * React component that setups a form input with Formik validation\n */\nconst FormikTextField = ({ property }: AppProps) => {\n  const { formikSlice } = useGlobalFormik();\n\n  const field = formikSlice.fieldsInfo.filter(\n    (item: any) => item.property === property\n  )[0];\n\n  // * Generate ChakraUI form component: input, select, textarea\n  return (\n    <Field\n      as={COMPONENT_TYPE[field.component]}\n      placeholder={field?.placeholder}\n      id={property}\n      autoComplete={field.suggest}\n      name={property}\n      type={field.type}\n      noValidate={false}\n    >\n      {field.options &&\n        field.options.map((item: any, i: number) => (\n          <option key={i}>{item}</option>\n        ))}\n    </Field>\n  );\n};\n\nexport default FormikTextField;\n","import useGlobalFormik from \"common/hooks/useGlobalFormik\";\nimport ImageCAPTCHA from \"./blocks/FormikImageCaptcha\";\nimport FormikNumberInput from \"./blocks/FormikNumberInput\";\nimport FormikStringArray from \"./blocks/FormikStringArray\";\nimport FormikTextField from \"./blocks/FormikTextField\";\nimport FormikValidationWrapper from \"./blocks/FormikValidationWrapper\";\n\ninterface AppProps {\n  /**\n   * Name of property\n   */\n  property: string;\n}\n\n/**\n * FlaskField\n *\n * React component that determines which field input should be rendered\n */\nconst FlaskField = ({ property }: AppProps) => {\n  const { formikSlice } = useGlobalFormik();\n\n  const field = formikSlice.fieldsInfo.filter(\n    (item: any) => item.property === property\n  )[0];\n\n  // * Image CAPTCHA\n  if (field.component === \"math\") {\n    return <ImageCAPTCHA />;\n  }\n\n  // * String array\n  if (field.component === \"stringArray\") {\n    return (\n      <FormikValidationWrapper\n        property={property}\n        children={<FormikStringArray property={property} />}\n      ></FormikValidationWrapper>\n    );\n  }\n\n  // * Number\n  if (field.component === \"number\") {\n    return (\n      <FormikValidationWrapper\n        property={property}\n        children={<FormikNumberInput property={property} />}\n      />\n    );\n  }\n\n  // * Select, input or text area\n  if (\n    field.component === \"select\" ||\n    field.component === \"input\" ||\n    field.component === \"textarea\"\n  ) {\n    return (\n      <FormikValidationWrapper\n        property={property}\n        children={<FormikTextField property={property} />}\n      ></FormikValidationWrapper>\n    );\n  }\n  return <div>Component does not have valid match</div>;\n};\n\nexport default FlaskField;\n","import { ReactNode } from \"react\";\n\ninterface AppProps {\n  /**\n   * `function` - runs when form is submitted\n   */\n  handleSubmit: any;\n  noValidate?: boolean;\n  children: ReactNode;\n}\n\n/**\n * GeneratedForm\n *\n * React component that wraps child in a form component and attaches a callback to the submit function\n */\nconst GeneratedForm = ({ children, noValidate, handleSubmit }: AppProps) => {\n  // * Disable default form behavior (enter = submit)\n  function onKeyDown(e: React.KeyboardEvent<HTMLFormElement>) {\n    if (e.code === \"Enter\" || e.code === \"NumpadEnter\") {\n      e.preventDefault();\n    }\n  }\n\n  return (\n    <form\n      onKeyDown={onKeyDown}\n      onSubmit={handleSubmit}\n      noValidate={noValidate !== undefined ? noValidate : false}\n    >\n      {children}\n    </form>\n  );\n};\n\nexport default GeneratedForm;\n","import { Flex, Heading, Text, VStack } from \"@chakra-ui/react\";\n\n/**\n * Invalid Token\n *\n * React component that displays when an invalid token is given\n */\nconst InvalidToken = () => {\n  return (\n    <Flex h=\"90vh\" align=\"center\" justify=\"center\">\n      <VStack maxW=\"xl\" textAlign=\"center\">\n        <Heading>Invalid link.</Heading>\n        <Text color=\"gray.500\">\n          Link may be expired or copied incorrectly. Please make sure you copied\n          the correct link from your email. If that doesn't work try requesting\n          another one.\n        </Text>\n      </VStack>\n    </Flex>\n  );\n};\n\nexport default InvalidToken;\n","import { FormikProvider, useFormik } from \"formik\";\nimport { ReactElement, useEffect } from \"react\";\nimport GeneratedForm from \"./GeneratedForm\";\nimport InvalidToken from \"./InvalidToken\";\nimport { AnimatePresence, motion } from \"framer-motion\";\ninterface AppProps {\n  postFormInput: any;\n  initialValue: any;\n  validationSchema: any;\n  noValidate: any;\n  submitHandler: any;\n  invalidToken: boolean;\n  formSession?: boolean;\n  isSubmitting: boolean;\n  children: (ctx: { isSubmitting: boolean }) => ReactElement;\n}\n\nconst FormikWrapper = ({\n  formSession,\n  postFormInput,\n  initialValue,\n  validationSchema,\n  noValidate,\n  submitHandler,\n  children,\n  invalidToken,\n  isSubmitting,\n}: AppProps) => {\n  // * Formik object given parameters from backend\n  const formik = useFormik({\n    initialValues: initialValue,\n    enableReinitialize: true,\n    validationSchema: validationSchema,\n    onSubmit: submitHandler,\n  });\n\n  // * Saves form in session every time value is updated\n  useEffect(() => {\n    let timer: ReturnType<typeof setTimeout>;\n    if (formSession && formik.values) {\n      timer = setTimeout(async () => {\n        await postFormInput({\n          save_session: true,\n          values: formik.values,\n        });\n      }, 500);\n    }\n    return () => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [formSession, formik.values]);\n\n  return (\n    <AnimatePresence>\n      <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}>\n        <FormikProvider value={formik}>\n          {invalidToken ? (\n            // * Invalid token page\n            <InvalidToken />\n          ) : (\n            // * Generated form\n            <GeneratedForm\n              handleSubmit={formik.handleSubmit}\n              noValidate={noValidate}\n            >\n              {children({ isSubmitting })}\n            </GeneratedForm>\n          )}\n        </FormikProvider>\n      </motion.div>\n    </AnimatePresence>\n  );\n};\n\nexport default FormikWrapper;\n","import * as Yup from \"yup\";\nimport { useParams } from \"react-router-dom\";\nimport { ReactElement, useEffect, useState } from \"react\";\nimport { buildYup } from \"schema-to-yup\";\n\nimport useFormikState from \"../../hooks/useGlobalFormik\";\nimport FormikWrapper from \"./FormikWrapper\";\nimport useAxiosWrapper from \"common/hooks/useAxiosWrapper\";\n// * Type for building form state\ninterface BuildFormType {\n  key: string;\n  validation_schema: any;\n  initial_values: any;\n  fields_info: any[];\n  loading: boolean;\n  hasToken: boolean;\n  hasCaptcha: boolean;\n  invalidToken: boolean;\n  csrf_token: string;\n  isSubmitting: boolean;\n}\n\ninterface AppProps {\n  /**\n   * `string` - Form key matches with the Flask form's form key in order to generate correct form object\n   */\n  formKey: string;\n\n  /**\n   * `object` - Field values in this object will reset to the inital state on form submit\n   */\n  resetAfterSubmit?: any;\n  /**\n   * `function` - This callback function will run after the form is successfully submitted, good for changing the state or navigating to another page after submission\n   */\n  runAfterSubmit?: (data: any, values: any) => void;\n  /**\n   * `boolean` - Determines if form should have vanilla valiation (incorrect input popups)\n   */\n  noValidate?: boolean;\n  /**\n   * `boolean` - Save form in session for user to come back to\n   */\n  formSession?: boolean;\n  /**\n   * Render props to return isSubmitting\n   */\n  children: (ctx: { isSubmitting: boolean }) => ReactElement;\n}\n\n/**\n * Flask Form\n *\n * React component that wraps a `Formik Form` and returns render props with generated Formik information. Takes in the associated `form key` into draws all form information from Flask backend to ensure the same validation.\n *\n * If form is a token form (email verification, reset password, etc), it will verify the key in the URL, then either display the needed page or an invalid token page.\n *\n * If the form is a token form with one field valid (only verifying token), the form will automatically submit the form on the component load\n *\n */\nconst FlaskForm = ({\n  formKey,\n  resetAfterSubmit,\n  runAfterSubmit,\n  noValidate,\n  formSession,\n  children,\n}: AppProps) => {\n  // * Get request to build form on component render\n  const [form, setForm] = useState<BuildFormType>({\n    key: \"\",\n    fields_info: [],\n    initial_values: {},\n    validation_schema: {},\n    loading: true,\n    hasToken: true,\n    invalidToken: false,\n    hasCaptcha: false,\n    csrf_token: \"\",\n    isSubmitting: false,\n  });\n\n  // * Builds form from particular form object given key\n  const { getAxios: getBuildForm } = useAxiosWrapper({\n    url: `build_form/${formKey}`,\n    method: \"GET\",\n  });\n\n  // * Create post request to give form input\n  const { postAxios: postFormInput } = useAxiosWrapper({\n    url: `build_form/${formKey}`,\n    method: \"POST\",\n  });\n\n  const params = useParams();\n  const { setFormik, setCaptcha, resetGlobalFormik } = useFormikState();\n\n  // * On component render, build formik form from backend parameters & validate token if given\n  useEffect(() => {\n    let timer: any;\n\n    const buildForm = async () => {\n      // * Reset Formik State\n      resetGlobalFormik();\n      setForm((prevState) => {\n        return {\n          ...prevState,\n          key: \"\",\n          loading: true,\n        };\n      });\n      const { data } = await getBuildForm();\n      //console.log(data);\n      // * Check for token, if token field exists then post token to check for it\n      // ? TODO add route matching for token fields only\n      if (\n        data.fields_info.filter((field: any) => field.property === \"token\")\n          .length > 0\n      ) {\n        const { data: tokenData } = await postFormInput({\n          validate_token: params.token,\n        });\n        if (tokenData.hasOwnProperty(\"error\")) {\n          setForm((prevState) => {\n            return { ...prevState, invalidToken: true };\n          });\n        } else {\n          // * If only 1 field, token field just auto submit the form to backend\n          if (data.fields_info.length === 1) {\n            // console.log(\"Only token field, just auto verify\");\n            const { data } = await postFormInput({\n              token: params.token,\n            });\n            if (runAfterSubmit) {\n              runAfterSubmit(data, {});\n            }\n          }\n        }\n        setForm((prevState) => {\n          return { ...prevState, hasToken: true };\n        });\n      }\n\n      // * Set CSRF token state, so future post requests will have token\n      setForm((prevState) => {\n        return {\n          ...prevState,\n          csrf_token: data.csrf_token,\n        };\n      });\n\n      // * Create Yup schema & set to inital validation schema state\n      const formSchema = buildYup(data.validation_schema, data.config);\n      setForm((prevState) => {\n        return {\n          ...prevState,\n          validation_schema: formSchema,\n        };\n      });\n\n      // * Build yup has some errors\n      data.fields_info\n        .filter((field: any) => field.property !== \"token\")\n        .forEach((field: any) => {\n          // * If ref value exists, edit to overwrite error msg\n          if (field.refValueFor.length > 0) {\n            const addMatch = Yup.object().shape({\n              confirm: Yup.string()\n                .oneOf(\n                  [Yup.ref(field.refValueFor), null],\n                  `Must match with ${field.refValueFor} field`\n                )\n                .required(\"Required\"),\n            });\n            const removed = formSchema.omit([\"confirm\"]);\n            const add = removed.concat(addMatch);\n            setForm((prevState) => {\n              return {\n                ...prevState,\n                validation_schema: add,\n              };\n            });\n          }\n          // * If array is required, let minimum length\n          if (field.required && field.component === \"stringArray\") {\n            let newShape: any = {};\n            newShape[field.property] = Yup.array()\n              .of(Yup.string())\n              .min(1, `${field.title} must have atleast 1 item`)\n              .required();\n            const addMatch = Yup.object().shape(newShape);\n            const removed = formSchema.omit([field.property]);\n            const add = removed.concat(addMatch);\n            setForm((prevState) => {\n              return {\n                ...prevState,\n                validation_schema: add,\n              };\n            });\n          }\n        });\n\n      // * Set CAPTCHA state, check if CAPTCHA exists first\n      const captcha = data.fields_info.filter(\n        (field: any) => field.property === \"math\"\n      );\n      if (captcha.length > 0) {\n        const field = captcha[0];\n        setCaptcha(field.img, field.audio);\n      }\n\n      setForm((prevState) => {\n        return {\n          ...prevState,\n          initial_values: data.initial_values,\n          fields_info: data.fields_info,\n          loading: false,\n          csrf_token: data.csrf_token,\n        };\n      });\n      setFormik({\n        key: formKey,\n        loading: false,\n        fieldsInfo: data.fields_info,\n      });\n    };\n    buildForm();\n    return () => {\n      // * Clear timer on component demount\n      if (timer) {\n        clearTimeout(timer);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const submitTest = async (values: any, { resetForm }: any) => {\n    setForm((prevState) => {\n      return {\n        ...prevState,\n        isSubmitting: true,\n      };\n    });\n\n    // * Reset certain form values if needed\n    if (resetAfterSubmit) {\n      resetForm({ values: { ...values, ...resetAfterSubmit } });\n    }\n    // * If token exists, send token along with usual form\n    let sentData = { ...values };\n    if (form.hasToken) {\n      sentData = { ...values, token: params.token };\n    }\n    const { data } = await postFormInput({\n      ...sentData,\n    });\n\n    if (runAfterSubmit) {\n      runAfterSubmit(data, values);\n    }\n    setForm((prevState) => {\n      return {\n        ...prevState,\n        isSubmitting: false,\n      };\n    });\n  };\n\n  // * Loads either an invalid token page or the generated form\n  return (\n    <>\n      {!form.loading && (\n        <FormikWrapper\n          postFormInput={postFormInput}\n          formSession={formSession}\n          initialValue={form.initial_values}\n          validationSchema={form.validation_schema}\n          noValidate={noValidate}\n          submitHandler={submitTest}\n          children={children}\n          isSubmitting={form.isSubmitting}\n          invalidToken={form.invalidToken}\n        />\n      )}\n    </>\n  );\n};\n\nexport default FlaskForm;\n","import { containsError, containsSuccess } from \"../utils\";\nimport useGlobalFormik from \"./useGlobalFormik\";\nimport useGlobalAlert from \"./useGlobalAlert\";\n\ninterface PostWrapperFunctionProps {\n  data: any;\n  onSuccess?: () => void;\n  successMsg?: string;\n  onFailure?: () => void;\n  failureMsg?: string;\n}\n\n/**\n * React hook that helps reduce redundant code when posting with `useAxios` to the BRAINWORKS API. It ultizes `useGlobalAlert` and and try and catch statements to help error check\n *\n * If JSON returns `success` or `error` it prints that message, otherwise it prints out success/error message from the API\n *\n * If request fails, then it prints out generic error message\n */\nconst useAPIDataAlert = (): {\n  /**\n   * Function that reduces redunancy of interpretting a JSON from the BRAINWORKS API\n   */\n  apiDataAlerter: ({\n    onSuccess,\n    successMsg,\n    onFailure,\n    failureMsg,\n    data,\n  }: PostWrapperFunctionProps) => Promise<void>;\n  /**\n   * Function that returns a standard error message\n   */\n  standardAlertError: () => void;\n  /**\n   * Function that puts a try catch statement around the given function, if there are errors it throws the standard alert error\n   */\n  tryCatchWrapper: (func: any) => void;\n} => {\n  const { showGlobalAlert } = useGlobalAlert();\n  const { formikSlice, newCaptcha } = useGlobalFormik();\n\n  const standardAlertError = () => {\n    showGlobalAlert(\"Something went wrong!\", \"Please try again later\");\n  };\n\n  const tryCatchWrapper = (func: any) => {\n    try {\n      func();\n    } catch {\n      standardAlertError();\n    }\n  };\n\n  const apiDataAlerter = async ({\n    onSuccess,\n    successMsg,\n    onFailure,\n    failureMsg,\n    data,\n  }: PostWrapperFunctionProps) => {\n    if (containsSuccess(data)) {\n      // * If object contains \"success\", alert either custom success message or one from back end\n      if (successMsg) {\n        showGlobalAlert(\"Success!\", successMsg, \"success\");\n      } else {\n        if (typeof data.success === \"string\") {\n          showGlobalAlert(\"Success!\", data.success, \"success\");\n        }\n      }\n      // * Run success function, if one is defined\n      if (onSuccess) {\n        onSuccess();\n      }\n    } else {\n      // * If object contains \"error\", alert either custom failure message or one from back end\n      if (containsError(data)) {\n        if (failureMsg) {\n          showGlobalAlert(\"Something went wrong!\", failureMsg, \"error\");\n        } else {\n          showGlobalAlert(\"Something went wrong!\", data.error);\n        }\n        // * If form has CAPTCHA, checking if image is set, if so set a new captcha\n        if (formikSlice.captcha.img.length > 0) {\n          newCaptcha();\n        }\n      }\n      // * Run failure function, if one is define\n      if (onFailure) {\n        onFailure();\n      }\n    }\n  };\n\n  return { apiDataAlerter, standardAlertError, tryCatchWrapper };\n};\n\nexport default useAPIDataAlert;\n","import { useToast } from \"@chakra-ui/react\";\nimport { hideAlert, showAlert } from \"../../store/features/alertSlice\";\nimport { useAppDispatch, useAppSelector } from \"../../store/hooks\";\nimport { AlertType, ShowAlertType } from \"../../store/models\";\n\n/**\n * @returns state to hide or show global alert system\n */\n\ntype ShowGlobalAlertType = (\n  title: string,\n  desc: string,\n  status?: \"error\" | \"info\" | \"warning\" | \"success\" | \"loading\" | undefined,\n  duration?: number | null\n) => void;\n\n// TODO: clean this up like the status\nconst useGlobalAlert = (): {\n  globalAlert: AlertType;\n  showGlobalAlert: ShowGlobalAlertType;\n  hideGlobalAlert: () => void;\n} => {\n  const globalAlert = useAppSelector((state) => state.alert);\n  const dispatch = useAppDispatch();\n  const toast = useToast();\n\n  const showGlobalAlert: ShowGlobalAlertType = (\n    title,\n    desc,\n    status,\n    duration\n  ) => {\n    const alert: ShowAlertType = {\n      title: title,\n      desc: desc,\n      status: status ? status : \"error\",\n    };\n    dispatch(showAlert(alert));\n    toast({\n      position: \"top\",\n      title: title,\n      description: desc,\n      status: status !== undefined ? status : \"error\",\n      duration: duration !== undefined ? duration : 5000,\n      isClosable: true,\n    });\n  };\n\n  const hideGlobalAlert = () => {\n    dispatch(hideAlert());\n  };\n\n  return { globalAlert, showGlobalAlert, hideGlobalAlert };\n};\n\nexport default useGlobalAlert;\n","import useAxios from \"axios-hooks\";\n\nimport {\n  resetFormikSlice,\n  setFormikSlice,\n  setNewCaptcha,\n} from \"../../store/features/formikSlice\";\nimport { FormikSliceType } from \"../../store/models\";\nimport { useAppDispatch, useAppSelector } from \"../../store/hooks\";\nimport { API_URL } from \"../templates/api\";\ninterface useFormikSliceReturnType {\n  formikSlice: any;\n  setFormik: (state: FormikSliceType) => void;\n  setCaptcha: any;\n  newCaptcha: any;\n  resetGlobalFormik: any;\n}\n\n/**\n * useGlobalFormik\n *\n * React hook that passes additional information globally for the formik forms\n */\nconst useGlobalFormik = (): useFormikSliceReturnType => {\n  const dispatch = useAppDispatch();\n  const formikSlice = useAppSelector((state) => state.formik);\n\n  /**\n   * getNewCaptcha\n   *\n   * Axios get request to get new information for the CAPTCHA\n   */\n  const [, getNewCaptcha] = useAxios(\n    {\n      url: `${API_URL}/new_captcha`,\n      withCredentials: true,\n    },\n    { manual: true }\n  );\n\n  /**\n   * resetGlobalFormik\n   *\n   * Redux reducer wrapper that resets the formikSlice to its initial values\n   */\n  const resetGlobalFormik = () => {\n    dispatch(resetFormikSlice());\n  };\n\n  /**\n   * setCaptcha\n   *\n   * Redux reducer wrapper that sets current CAPTCHA information in formikSlice\n   */\n  const setCaptcha = (img: string, audio: string) => {\n    dispatch(setNewCaptcha({ img: img, audio: audio }));\n  };\n\n  /**\n   * setFormik\n   *\n   * Function that wraps formikSlice dispatch\n   */\n  const setFormik = ({ key, fieldsInfo, loading }: FormikSliceType) => {\n    dispatch(\n      setFormikSlice({\n        key,\n        fieldsInfo,\n        loading,\n      })\n    );\n  };\n\n  /**\n   * newCaptcha\n   *\n   * Function that makes a get request to get a new captcha img & audio\n   */\n  const newCaptcha = async () => {\n    const { data } = await getNewCaptcha();\n    if (data) {\n      setCaptcha(data.img, data.audio);\n    } else {\n      setCaptcha(\"\", \"\");\n    }\n  };\n\n  return {\n    formikSlice,\n    setFormik,\n    setCaptcha,\n    newCaptcha,\n    resetGlobalFormik,\n  };\n};\n\nexport default useGlobalFormik;\n","/**\n * Function prevents default behavior of form, to reload\n */\nexport function preventFormSubmission(e: React.KeyboardEvent<HTMLFormElement>) {\n  if (e.key === \"Enter\") {\n    e.preventDefault();\n  }\n}\n\n/**\n * Function that returns true if object has key success\n */\nexport function containsSuccess(obj: any) {\n  return obj?.hasOwnProperty(\"success\");\n}\n\n/**\n * Function that returns true if object has key error\n */\nexport function containsError(obj: any) {\n  return obj?.hasOwnProperty(\"error\");\n}\n\n/**\n * Function that returns true if string is empty\n */\nexport function emptyString(s: string) {\n  return s.length === 0;\n}\n\n/**\n * Function that overwrites the yup to schema object because\n */\nexport const fixYupToSchemaObject = (s: string) => {};\n\n/**\n * Function that uses binary search to get autocomplete input\n */\nconst findMatch = (text: string, which = \"first\", arr: String[]) => {\n  if (text) {\n    text = text.toLowerCase();\n    let start = 0;\n    let end = arr.length - 1;\n    let candidate_index = null;\n    while (start <= end) {\n      let mid = Math.floor((start + end) / 2);\n      let elem = arr[mid][0].toLowerCase();\n      if (elem.substr(0, text.length) === text) {\n        candidate_index = mid;\n        if (which === \"first\") end = mid - 1;\n        else start = mid + 1;\n      } else if (elem < text) start = mid + 1;\n      else end = mid - 1;\n    }\n    return candidate_index;\n  }\n};\nexport const matchItems = (text: string, arr: String[]) => {\n  let matches: any = [];\n  let start = findMatch(text, \"first\", arr); // get first match\n  let end = findMatch(text, \"last\", arr); // get last match\n  if (start != null && end != null) {\n    matches = arr.slice(start, end + 1);\n  }\n  if (matches.length > 0) {\n    matches.sort(function (a: string, b: string) {\n      return a[1] < b[1] ? 1 : -1;\n    });\n    matches = matches.slice(0, 5);\n  }\n  return matches;\n};\n\n/**\n * Function that gets all info of field given the property name\n */\nexport function getFieldInfo(arr: any[], property: string) {\n  return arr.filter((item: any) => item.property === property).shift();\n}\n"],"names":["Card","forwardRef","ref","children","boxProps","border","borderColor","overflow","opacity","bg","h","w","hideInvalidMsg","property","formik","useFormikContext","errors","field","useGlobalFormik","formikSlice","fieldsInfo","filter","item","isRequired","required","isInvalid","touched","htmlFor","title","toString","newCaptcha","captcha","p","spacing","textAlign","fontSize","color","fontWeight","mb","startColor","endColor","isLoaded","img","length","src","DOMPurify","align","as","Input","id","autoComplete","name","noValidate","colorScheme","brandColorScheme","size","icon","onClick","values","setFieldValue","onChange","value","min","max","array","onClose","map","index","variant","filtered","searchQuery","curSelected","show","setCurSelected","addFormValue","borderRadius","pos","top","zIndex","tabIndex","boxShadow","result","onMouseOver","ml","toLocaleString","showGlobalAlert","useGlobalAlert","inputRef","useRef","useState","curInput","setCurInput","autoArr","setAutoArr","setShow","getFieldInfo","includes","valuesArr","useAxios","url","API_URL","autocomplete","withCredentials","manual","getAutocomplete","useEffect","loadAutocomplete","data","useMemo","matchItems","type","e","currentTarget","onBlur","_event","setTimeout","onFocus","onKeyDown","event","key","newValue","prevState","COMPONENT_TYPE","select","Select","input","textarea","Textarea","component","placeholder","suggest","options","i","handleSubmit","code","preventDefault","onSubmit","undefined","justify","maxW","formSession","postFormInput","initialValue","validationSchema","submitHandler","invalidToken","isSubmitting","useFormik","initialValues","enableReinitialize","timer","save_session","clearTimeout","AnimatePresence","motion","initial","animate","formKey","resetAfterSubmit","runAfterSubmit","fields_info","initial_values","validation_schema","loading","hasToken","hasCaptcha","csrf_token","form","setForm","getBuildForm","useAxiosWrapper","method","getAxios","postAxios","params","useParams","useFormikState","setFormik","setCaptcha","resetGlobalFormik","buildForm","validate_token","token","hasOwnProperty","formSchema","buildYup","config","forEach","refValueFor","addMatch","Yup","shape","confirm","oneOf","add","omit","concat","newShape","of","audio","submitTest","resetForm","sentData","standardAlertError","apiDataAlerter","onSuccess","successMsg","onFailure","failureMsg","containsSuccess","success","containsError","error","tryCatchWrapper","func","globalAlert","useAppSelector","state","alert","dispatch","useAppDispatch","toast","useToast","desc","status","duration","showAlert","position","description","isClosable","hideGlobalAlert","hideAlert","getNewCaptcha","setNewCaptcha","setFormikSlice","resetFormikSlice","obj","findMatch","text","which","arr","toLowerCase","start","end","candidate_index","mid","Math","floor","elem","substr","matches","slice","sort","a","b","shift"],"sourceRoot":""}